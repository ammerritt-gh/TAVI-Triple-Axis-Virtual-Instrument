/*******************************************************************************
*
* Component: FlatEllipse_finite_mirror
*
* %I
* Written by: Christoph Herb (original), optimized by Claude
* Version: 0.2
* Origin: TU Munich
* Date: 2024
*
* %D
* Nested Mirror Optics (NMO) component for neutron focusing using flat elliptical
* mirrors. Supports reading mirror positions (B-values) and m-values from files,
* with optional silicon substrate refraction modeling.
*
* Based on the paper: "Nested mirror optics for neutron extraction, transport, 
* and focusing" - Herb et al., NIM-A 1040 (2022) 167154
*
* %P
* INPUT PARAMETERS:
* sourceDist:        [m]   Distance used for calculating mirror spacing (usually equals LStart)
* LStart:            [m]   Z-coordinate of the first focal point of the ellipses
* LEnd:              [m]   Z-coordinate of the second focal point of the ellipses
* lStart:            [m]   Z-coordinate of the mirror assembly start
* lEnd:              [m]   Z-coordinate of the mirror assembly end
* r_0:               [m]   Distance to optical axis at lStart for outermost mirror (used if no file)
* nummirror:         [1]   Number of mirrors (overridden if file provided)
* mf:                [1]   m-value of inner (front) coating, m>10 gives perfect reflection
* mb:                [1]   m-value of outer (back) coating, m>10 gives perfect reflection
* mirror_width:      [m]   Thickness of mirror substrate (0 = infinitely thin)
* mirror_sidelength: [m]   Lateral extension of mirror system along y
* doubleReflections: [1]   Allow reflections from mirror backside (0=no, 1=yes)
* enable_silicon_refraction: [1] Model refraction at silicon interfaces (0=no, 1=yes)
* rfront_inner_file: [str] File with mirror distances: "index  b_value" per line
* mirror_mvalue_file:[str] File with per-mirror m-values: "index  mf  mb" per line
*
* %E
*
*******************************************************************************/

DEFINE COMPONENT FlatEllipse_finite_mirror_optimized
SETTING PARAMETERS (
    sourceDist = 0,
    LStart = 0.6,
    LEnd = 0.6,
    lStart = 0.,
    lEnd = 0.,
    r_0 = 0.02076,
    int nummirror = 9,
    mf = 4,
    mb = 0,
    mirror_width = 0.003,
    mirror_sidelength = 1,
    doubleReflections = 0,
    int enable_silicon_refraction = 1,
    string rfront_inner_file = "NULL",
    string mirror_mvalue_file = "NULL"
)
OUTPUT PARAMETERS(s)

SHARE
%{
    %include "conic_finite_mirror_fixed.h"
    %include "calciterativemirrors_fixed.h"
    %include "read_table-lib"
    
    /***************************************************************************
    * Binary search to find which mirror channel a neutron is in
    * Returns: index of the mirror whose front surface is <= x_pos, or -1 if none
    * For ~80 mirrors: O(log n) ≈ 7 comparisons vs O(n) = 80 comparisons
    ***************************************************************************/
    int find_mirror_channel_binary(double x_pos, double *r_abs, double *r_outer, int n) {
        int low = 0;
        int high = n - 1;
        int result = -1;
        
        // Mirrors are ordered from outermost (index 0, largest r) to innermost
        // We want to find the first mirror where r_abs[i] <= x_pos < r_outer[i]
        while (low <= high) {
            int mid = (low + high) / 2;
            if (r_abs[mid] <= x_pos) {
                // This mirror's inner surface is inside or at x_pos
                // Check if we're within this mirror's substrate
                if (x_pos < r_outer[mid]) {
                    return mid;  // Found: neutron is in this mirror's substrate
                }
                // x_pos is outside this mirror, look at outer mirrors (smaller indices)
                high = mid - 1;
            } else {
                // This mirror's inner surface is outside x_pos
                // Look at inner mirrors (larger indices, smaller r)
                low = mid + 1;
            }
        }
        return result;  // Not in any substrate
    }
    
    /***************************************************************************
    * Linear search fallback for validation/debugging
    ***************************************************************************/
    int find_mirror_channel_linear(double x_pos, double *r_abs, double *r_outer, int n) {
        for (int i = 0; i < n; i++) {
            if (r_outer[i] >= x_pos && r_abs[i] <= x_pos) {
                return i;
            }
            if (r_outer[i] < x_pos) {
                break;  // All further mirrors are closer to axis
            }
        }
        return -1;
    }
%}

DECLARE
%{
    Scene s;
    Point p1;
    
    // Mirror geometry arrays
    double *rfront_inner;      // B-values: distances to optical axis at lStart
    double *rfront_inner_abs;  // Pre-computed |rfront_inner[i]| for fast lookup
    double *rfront_outer_abs;  // Pre-computed |rfront_inner[i]| + mirror_width
    
    // Per-mirror m-value arrays
    double *mf_array;
    double *mb_array;
    int use_mvalue_file;       // Flag: are we using per-mirror m-values?
    
    // State tracking
    int silicon_tracking;      // 0: no tracking, -1: in air, +1: in silicon
    
    // Table for file reading
    t_Table rsTable;
    t_Table mvalueTable;
    int rsTable_loaded;
    int mvalueTable_loaded;
    
    // Silicon optical properties
    double m_silicon;          // Critical angle parameter for silicon
%}

INITIALIZE
%{
    rsTable_loaded = 0;
    mvalueTable_loaded = 0;
    use_mvalue_file = 0;
    m_silicon = 0.478;  // m-value for silicon (per Peter Böni)
    
    printf("FlatEllipse_finite_mirror: Initializing NMO component\n");
    
    //=========================================================================
    // STEP 1: Load or calculate mirror B-values (radial positions)
    //=========================================================================
    if (rfront_inner_file && strlen(rfront_inner_file) && 
        strcmp(rfront_inner_file, "NULL") && strcmp(rfront_inner_file, "0")) {
        
        printf("  Loading B-values from file: %s\n", rfront_inner_file);
        if (Table_Read(&rsTable, rfront_inner_file, 1) <= 0) {
            exit(fprintf(stderr, "ERROR: %s: Cannot read B-values file %s\n", 
                        NAME_CURRENT_COMP, rfront_inner_file));
        }
        rsTable_loaded = 1;
        nummirror = rsTable.rows;
        
        rfront_inner = malloc(sizeof(double) * nummirror);
        if (!rfront_inner) {
            exit(fprintf(stderr, "ERROR: %s: Memory allocation failed for rfront_inner\n",
                        NAME_CURRENT_COMP));
        }
        
        for (int i = 0; i < nummirror; i++) {
            rfront_inner[i] = Table_Index(rsTable, i, 1);
        }
        printf("  Loaded %d mirror positions from file\n", nummirror);
        
    } else {
        printf("  Calculating B-values automatically (nummirror=%d, r_0=%g m)\n", 
               nummirror, r_0);
        rfront_inner = get_r_at_z0(nummirror, 0, r_0, lStart, sourceDist, LEnd, lStart, lEnd);
        if (!rfront_inner) {
            exit(fprintf(stderr, "ERROR: %s: get_r_at_z0 failed\n", NAME_CURRENT_COMP));
        }
    }
    
    //=========================================================================
    // STEP 2: Load per-mirror m-values if provided
    //=========================================================================
    if (mirror_mvalue_file && strlen(mirror_mvalue_file) && 
        strcmp(mirror_mvalue_file, "NULL") && strcmp(mirror_mvalue_file, "0")) {
        
        printf("  Loading per-mirror m-values from file: %s\n", mirror_mvalue_file);
        if (Table_Read(&mvalueTable, mirror_mvalue_file, 1) <= 0) {
            exit(fprintf(stderr, "ERROR: %s: Cannot read m-value file %s\n", 
                        NAME_CURRENT_COMP, mirror_mvalue_file));
        }
        mvalueTable_loaded = 1;
        
        if (mvalueTable.rows != nummirror) {
            fprintf(stderr, "WARNING: %s: m-value file has %ld rows but %d mirrors defined\n",
                    NAME_CURRENT_COMP, mvalueTable.rows, nummirror);
        }
        
        mf_array = malloc(sizeof(double) * nummirror);
        mb_array = malloc(sizeof(double) * nummirror);
        if (!mf_array || !mb_array) {
            exit(fprintf(stderr, "ERROR: %s: Memory allocation failed for m-value arrays\n",
                        NAME_CURRENT_COMP));
        }
        
        for (int i = 0; i < nummirror; i++) {
            mf_array[i] = Table_Index(mvalueTable, i, 1);
            mb_array[i] = Table_Index(mvalueTable, i, 2);
        }
        use_mvalue_file = 1;
        printf("  Loaded per-mirror m-values for %d mirrors\n", nummirror);
        
    } else {
        // Use uniform m-values
        mf_array = malloc(sizeof(double) * nummirror);
        mb_array = malloc(sizeof(double) * nummirror);
        if (!mf_array || !mb_array) {
            exit(fprintf(stderr, "ERROR: %s: Memory allocation failed for m-value arrays\n",
                        NAME_CURRENT_COMP));
        }
        for (int i = 0; i < nummirror; i++) {
            mf_array[i] = mf;
            mb_array[i] = mb;
        }
        printf("  Using uniform m-values: mf=%g, mb=%g\n", mf, mb);
    }
    
    //=========================================================================
    // STEP 3: Pre-compute absolute mirror boundaries for fast lookup
    //=========================================================================
    rfront_inner_abs = malloc(sizeof(double) * nummirror);
    rfront_outer_abs = malloc(sizeof(double) * nummirror);
    if (!rfront_inner_abs || !rfront_outer_abs) {
        exit(fprintf(stderr, "ERROR: %s: Memory allocation failed for boundary arrays\n",
                    NAME_CURRENT_COMP));
    }
    
    for (int i = 0; i < nummirror; i++) {
        rfront_inner_abs[i] = fabs(rfront_inner[i]);
        rfront_outer_abs[i] = rfront_inner_abs[i] + mirror_width;
    }
    
    //=========================================================================
    // STEP 4: Set up silicon tracking mode
    //=========================================================================
    if (mirror_width == 0) {
        silicon_tracking = 0;  // No substrate tracking needed
        printf("  Silicon tracking: DISABLED (mirror_width=0)\n");
    } else {
        silicon_tracking = -1; // Start in air
        printf("  Silicon tracking: %s (mirror_width=%g m)\n", 
               enable_silicon_refraction ? "ENABLED" : "GEOMETRY ONLY", mirror_width);
    }
    
    if (sourceDist == 0) {
        sourceDist = LStart;
    }
    
    //=========================================================================
    // STEP 5: Build the mirror geometry
    //=========================================================================
    s = makeScene();
    
    printf("  Building mirror geometry:\n");
    for (int i = 0; i < nummirror; i++) {
        p1 = makePoint(rfront_inner[i], 0, lStart);
        addFlatEllipse(LStart, LEnd, p1, lStart, lEnd, 
                      -mirror_sidelength/2, mirror_sidelength/2, 
                      mf_array[i], doubleReflections, &s);
        
        if (i < 5 || i == nummirror-1) {
            printf("    Mirror[%d]: b=%+.6f m, mf=%.2f", i, rfront_inner[i], mf_array[i]);
            if (mirror_width > 0) printf(", mb=%.2f", mb_array[i]);
            printf("\n");
        } else if (i == 5) {
            printf("    ... (%d more mirrors) ...\n", nummirror - 6);
        }
    }
    
    // Add mirror backsides if substrate has finite thickness
    if (mirror_width > 0) {
        for (int i = 0; i < nummirror; i++) {
            p1 = makePoint(rfront_inner[i] + mirror_width, 0, lStart);
            addFlatEllipse(LStart, LEnd, p1, lStart, lEnd,
                          -mirror_sidelength/2, mirror_sidelength/2,
                          mb_array[i], doubleReflections, &s);
        }
        printf("  Added %d mirror backsides\n", nummirror);
    }
    
    // End disk to catch neutrons exiting the assembly
    addDisk(lEnd, 0.0, 2000, &s);
    
    printf("  NMO initialization complete: %d mirrors, focal length f1=%g m, f2=%g m\n",
           nummirror, LStart, LEnd);
%}

TRACE
%{
    double dt_prop;
    double x_check;
    int mirror_idx;
    int neutron_in_silicon;
    
    // Propagate neutron to the entrance plane of the NMO
    dt_prop = (-z + lStart) / vz;
    
    #ifdef DEBUG_NMO
    if (dt_prop < 0) {
        printf("WARNING: Negative propagation time dt=%g (neutron moving away from NMO?)\n", dt_prop);
    }
    #endif
    
    PROP_DT(dt_prop);
    
    // Initialize particle state
    neutron_in_silicon = silicon_tracking;  // -1 (air) or 0 (no tracking)
    
    //=========================================================================
    // Determine if neutron enters through a silicon substrate
    //=========================================================================
    if (mirror_width > 0) {
        x_check = fabs(x);
        
        // Use binary search for O(log n) performance with many mirrors
        mirror_idx = find_mirror_channel_binary(x_check, rfront_inner_abs, 
                                                 rfront_outer_abs, nummirror);
        
        if (mirror_idx >= 0) {
            // Neutron enters through silicon substrate
            neutron_in_silicon = 1;
        }
    }
    
    // Create particle for tracing
    Particle pa = makeParticle(x, y, z, vx, vy, vz, t, sx, sy, sz, neutron_in_silicon, p);
    
    // Apply entrance refraction if entering silicon
    if (neutron_in_silicon == 1 && enable_silicon_refraction) {
        Vec nStart = makeVec(0, 0, 1);  // Surface normal in beam direction
        refractNeutronFlat(&pa, nStart, 0, m_silicon);
    }
    
    //=========================================================================
    // Trace neutron through the mirror assembly
    //=========================================================================
    traceSingleNeutron(&pa, s);
    
    //=========================================================================
    // Apply exit refraction if neutron exits through silicon
    //=========================================================================
    if (pa.silicon == 1 && enable_silicon_refraction) {
        Vec nEnd = makeVec(0, 0, 1);
        refractNeutronFlat(&pa, nEnd, m_silicon, 0);
    }
    
    //=========================================================================
    // Transfer particle state back to McStas
    //=========================================================================
    x = pa._x;
    y = pa._y;
    z = pa._z;
    vx = pa._vx;
    vy = pa._vy;
    vz = pa._vz;
    t = pa._t;
    sx = pa._sx;
    sy = pa._sy;
    sz = pa._sz;
    p = pa.w;
    
    if (pa.absorb)
        ABSORB;
    
    SCATTER;
%}

FINALLY
%{
    printf("FlatEllipse_finite_mirror: Cleaning up\n");
    
    // Free allocated arrays
    if (rfront_inner) free(rfront_inner);
    if (rfront_inner_abs) free(rfront_inner_abs);
    if (rfront_outer_abs) free(rfront_outer_abs);
    if (mf_array) free(mf_array);
    if (mb_array) free(mb_array);
    
    // Free loaded tables
    if (rsTable_loaded) Table_Free(&rsTable);
    if (mvalueTable_loaded) Table_Free(&mvalueTable);
    
    // Clean up scene
    finishSimulation(&s);
%}

MCDISPLAY
%{
    // Enlarge xy-plane when mcdisplay is ran with --zoom
    magnify("xy");
    
    // Draw xy-axis contour for Conic Surfaces
    int i;
    for (i = 0; i < s.num_c; i++) {
        double step = (s.c[i].ze - s.c[i].zs) / 100;
        double cz;
        for (cz = s.c[i].zs + step; cz <= s.c[i].ze; cz += step) {
            double rp = rConic(cz - step, s.c[i]);
            double rc = rConic(cz, s.c[i]);
            
            line(0, rp, cz - step, 0, rc, cz);
            line(0, -rp, cz - step, 0, -rc, cz);
            line(rp, 0, cz - step, rc, 0, cz);
            line(-rp, 0, cz - step, -rc, 0, cz);
        }
    }
    
    // Draw xy-axis cross hairs for Disks
    for (i = 0; i < s.num_di; i++) {
        line(s.di[i].r0, 0, s.di[i].z0, s.di[i].r1, 0, s.di[i].z0);
        line(-s.di[i].r0, 0, s.di[i].z0, -s.di[i].r1, 0, s.di[i].z0);
        line(0, s.di[i].r0, s.di[i].z0, 0, s.di[i].r1, s.di[i].z0);
        line(0, -s.di[i].r0, s.di[i].z0, 0, -s.di[i].r1, s.di[i].z0);
    }
%}

END
