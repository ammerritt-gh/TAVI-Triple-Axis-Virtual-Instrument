/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Source_div_Maxwellian_v2
*
* %I
* Written by: KL
* Date: November 20, 1998
* Modified by: KL, 8 October 2001
* Modified by: 2025 - Fixed Maxwellian sampling and divergence banding
* Origin: Risoe
*
* Neutron source with Gaussian or uniform divergence and proper Maxwellian option
*
* %D
* The routine is a rectangular neutron source, which has a gaussian or uniform
* divergent output in the forward direction.
* The neutron energy is distributed between lambda0-dlambda and
* lambda0+dlambda or between E0-dE and E0+dE. The flux unit is specified
* in n/cm2/s/st/energy unit (meV or Angs).
*
* For Maxwellian distribution (energy_distribution=2), the distribution peaks 
* at energy E0. The parameter dE is not used for sampling but still affects
* the weight calculation.
*
* Example: Source_div_Maxwellian_v2(xwidth=0.1, yheight=0.1, focus_aw=2, focus_ah=2, E0=14, dE=2, energy_distribution=2)
*
* %P
* xwidth: [m]                        Width of source
* yheight: [m]                       Height of source
* focus_aw: [deg]                    FWHM (Gaussian) or maximal (uniform) horz. width divergence
* focus_ah: [deg]                    FWHM (Gaussian) or maximal (uniform) vert. height divergence
* E0: [meV]                          Mean energy of neutrons. For Maxwellian, peak is at E0.
* dE: [meV]                          Energy half spread of neutrons.
* lambda0: [Ang]                     Mean wavelength of neutrons (only relevant for E0=0)
* dlambda: [Ang]                     Wavelength half spread of neutrons.
* energy_distribution: [0|1|2]       Criterion: 0: uniform, 1: Gaussian, 2: Maxwellian
* divergence_distribution: [0|1]     Criterion: 0: uniform, 1: Gaussian distributions
* flux: [1/(s cm 2 st energy_unit)]  flux per energy unit, Angs or meV
*
* %E
*******************************************************************************/

DEFINE COMPONENT Source_div_Maxwellian_v2
DEFINITION PARAMETERS ()
SETTING PARAMETERS (xwidth, yheight, focus_aw, focus_ah, E0=0.0, dE=0.0, 
                    lambda0=0.0, dlambda=0.0, energy_distribution=0, 
                    divergence_distribution=0, flux=1)
OUTPUT PARAMETERS ()
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

DECLARE
%{
double sigmah;
double sigmav;
double p_init;
double dist;
double focus_xw;
double focus_yh;
%}

INITIALIZE
%{
  sigmah = DEG2RAD*focus_aw/(sqrt(8.0*log(2.0)));
  sigmav = DEG2RAD*focus_ah/(sqrt(8.0*log(2.0)));

  if (xwidth < 0 || yheight < 0 || focus_aw < 0 || focus_ah < 0) {
      printf("Source_div_Maxwellian_v2: %s: Error in input parameter values!\n"
             "ERROR       Exiting\n",
           NAME_CURRENT_COMP);
      exit(0);
  }
  if ((!lambda0 && !E0 && !dE && !dlambda)) {
    printf("Source_div_Maxwellian_v2: %s: You must specify either a wavelength or energy range!\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  if ((!lambda0 && !dlambda && (E0 <= 0 || dE < 0 || E0-dE <= 0))
    || (!E0 && !dE && (lambda0 <= 0 || dlambda < 0 || lambda0-dlambda <= 0))) {
    printf("Source_div_Maxwellian_v2: %s: Unmeaningful definition of wavelength or energy range!\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
      exit(0);
  }
  
  /* compute distance to next component */
  Coords ToTarget;
  double tx,ty,tz;
  ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+1),POS_A_CURRENT_COMP);
  ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
  coords_get(ToTarget, &tx, &ty, &tz);
  dist=sqrt(tx*tx+ty*ty+tz*tz);
  
  /* compute target area */
  if (dist) {
    focus_xw=dist*tan(focus_aw*DEG2RAD);
    focus_yh=dist*tan(focus_ah*DEG2RAD);
  }

  p_init  = flux*1e4*xwidth*yheight/mcget_ncount();
  if (!focus_aw || !focus_ah)
    exit(printf("Source_div_Maxwellian_v2: %s: Zero divergence defined. \n"
                "ERROR       Use non zero values for focus_aw and focus_ah.\n",
           NAME_CURRENT_COMP));
  p_init *= 2*fabs(DEG2RAD*focus_aw*sin(DEG2RAD*focus_ah/2));  /* solid angle */
  if (dlambda)
    p_init *= 2*dlambda;
  else if (dE)
    p_init *= 2*dE;
%}

TRACE
%{
  double E, lambda, v;
  double thetah, thetav;
  double tan_h, tan_v;

  p = p_init;
  z = 0;
  t = 0;

  /* Position: uniform over source area */
  x = randpm1() * xwidth / 2.0;
  y = randpm1() * yheight / 2.0;

  /* Energy/wavelength sampling */
  if (lambda0 == 0) {
    if (energy_distribution == 0) {
      /* Uniform energy distribution */
      E = E0 + dE * randpm1();
    } 
    else if (energy_distribution == 1) {
      /* Gaussian energy distribution */
      E = E0 + randnorm() * dE;
    } 
    else if (energy_distribution == 2) {
      /* 
       * Maxwellian energy distribution: P(E) ~ sqrt(E) * exp(-E / kT)
       * This is a Gamma(3/2, kT) distribution, which peaks at kT/2.
       * 
       * To have the peak at E0, we set kT = 2*E0.
       *
       * Sampling method: Gamma(3/2) = Gamma(1) + Gamma(1/2)
       *   - Gamma(1) with scale theta: -theta * log(U)
       *   - Gamma(1/2) with scale theta: theta * N^2 / 4, where N ~ Normal(0,1)
       *
       * So: E = kT * (-log(U) + N^2/4) where kT = 2*E0
       */
      double u1, n1;
      double kT = 2.0 * E0;  /* So peak is at kT/2 = E0 */
      
      /* Sample Gamma(1, 1): exponential */
      u1 = rand01();
      if (u1 < 1e-10) u1 = 1e-10;  /* Avoid log(0) */
      
      /* Sample Gamma(1/2, 1) using squared normal */
      n1 = randnorm();
      
      /* Combine for Gamma(3/2, kT) */
      E = kT * (-log(u1) + 0.25 * n1 * n1);
      
      /* Ensure positive energy */
      if (E <= 0) E = 1e-6;
    }
    v = sqrt(E) * SE2V;
  } 
  else {
    /* Wavelength-based sampling */
    if (energy_distribution == 0) {
      lambda = lambda0 + dlambda * randpm1();
    } 
    else if (energy_distribution == 1) {
      lambda = lambda0 + randnorm() * dlambda;
    }
    v = K2V * (2 * PI / lambda);
  }

  /* Divergence sampling */
  if (divergence_distribution == 1) {
    /* Gaussian divergence */
    thetah = randnorm() * sigmah;
    thetav = randnorm() * sigmav;
  } 
  else {
    /* 
     * Uniform divergence over [-focus_aw/2, +focus_aw/2] degrees
     * Use completely independent random calls for each axis
     * to avoid any correlation artifacts
     */
    double rh = rand01();
    double rv = rand01();
    thetah = (rh - 0.5) * focus_aw * DEG2RAD;
    thetav = (rv - 0.5) * focus_ah * DEG2RAD;
  }

  /* Calculate velocity components */
  tan_h = tan(thetah);
  tan_v = tan(thetav);

  vz = v / sqrt(1.0 + tan_v*tan_v + tan_h*tan_h);
  vy = tan_v * vz;
  vx = tan_h * vz;
%}

MCDISPLAY
%{
  
  multiline(5, -xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0, -yheight/2.0, 0.0);
  if (dist) {
    dashed_line(0,0,0, -focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2, focus_yh/2,dist, 4);
    dashed_line(0,0,0, -focus_xw/2, focus_yh/2,dist, 4);
  }
%}

END
