/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Source_gen_Maxwellian
*
* %I
* Written by: Emmanuel Farhi, Kim Lefmann
* Date: Aug 27, 2001
* Origin: ILL/Risoe
* Modified by: 2025 - Direct Maxwellian sampling for improved efficiency
*
* Circular/squared neutron source with DIRECT Maxwellian energy sampling
*
* %D
* This is a modified version of Source_gen that samples neutron energies 
* DIRECTLY from Maxwellian distributions rather than sampling uniformly in 
* wavelength and weighting. This provides much better Monte Carlo efficiency
* when using Maxwellian spectra over wide energy ranges.
*
* The component supports up to 3 Maxwellian distributions (T1/I1, T2/I2, T3/I3).
* When multiple temperatures are specified, neutrons are sampled from the 
* combined distribution with probability proportional to the integrated 
* intensity of each Maxwellian.
*
* The angular divergence can be set either by specifying a target rectangle
* (focus_xw, focus_yh, dist) or directly using divergence angles (focus_aw, 
* focus_ah in degrees).
*
* For non-Maxwellian use (flux_file or no temperature), the component falls
* back to the original uniform wavelength sampling with weighting.
*
* Usage example:
*   Source_gen_Maxwellian(yheight=0.1, xwidth=0.1, T1=300, I1=1e13, 
*                         focus_aw=4, focus_ah=4, Emin=1, Emax=200)
*
* <b>Some neutron facility parameters:</b>
* FRM2 thermal,20MW   T1=285.6,I1=3.06e13,T2=300.0,I2=1.68e12,T3=429.9,I3=6.77e12
* ILL Thermal tube    T1=683.7,I1=0.5874e+13,T2=257.7,I2=2.5099e+13,T3=16.7,I3=1.0343e+12
* ILL Hot source      T1=1695, I1=1.74e13,T2=708,  I2=3.9e12 (58MW)
*
* %P
* radius: [m]           Radius of circle in (x,y,0) plane where neutrons are generated.
* target_index: [1]     relative index of component to focus at, e.g. next is +1
* focus_xw: [m]         Width of target.
* focus_yh: [m]         Height of target.
* Emin: [meV]           Minimum energy of neutrons
* Emax: [meV]           Maximum energy of neutrons
* E0: [meV]             Mean energy of neutrons.
* dE: [meV]             Energy spread of neutrons, half width.
* Lmin: [AA]            Minimum wavelength of neutrons
* Lmax: [AA]            Maximum wavelength of neutrons
* lambda0: [AA]         Mean wavelength of neutrons.
* dlambda: [AA]         Wavelength spread of neutrons, half width
* dist: [m]             Distance to target along z axis.
* yheight: [m]          Source y-height
* xwidth: [m]           Source x-width
* zdepth: [m]           Source z-depth (for time spread)
* focus_aw: [deg]       maximal (uniform) horz. width divergence
* focus_ah: [deg]       maximal (uniform) vert. height divergence
* T1: [K]               Temperature of first Maxwellian, 0=none
* I1: [1/(cm**2*sr)]    Flux of first Maxwellian
* T2: [K]               Temperature of second Maxwellian, 0=none
* I2: [1/(cm**2*sr)]    Flux of second Maxwellian
* T3: [K]               Temperature of third Maxwellian, 0=none
* I3: [1/(cm**2*sr)]    Flux of third Maxwellian
* flux_file: [str]      Name of wavelength distribution file (disables direct sampling)
* flux_file_perAA: [1]  Flux file is per Angstrom
* flux_file_log: [1]    Use log scale for flux file
* xdiv_file: [str]      Horizontal phase space distribution file
* ydiv_file: [str]      Vertical phase space distribution file
* verbose: [0/1]        Display info about the source. -1 to deactivate.
*
* %E
******************************************************************************/

DEFINE COMPONENT Source_gen_Maxwellian
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string flux_file="NULL", string xdiv_file="NULL", string ydiv_file="NULL",
radius=0.0, dist=0, focus_xw=0.045, focus_yh=0.12, focus_aw=0, focus_ah=0,
E0=0, dE=0, lambda0=0, dlambda=0, I1=1,
yheight=0.1, xwidth=0.1, verbose=0, T1=0,
flux_file_perAA=0, flux_file_log=0,
Lmin=0,Lmax=0,Emin=0,Emax=0,T2=0,I2=0,T3=0,I3=0,zdepth=0, int target_index=+1)
OUTPUT PARAMETERS ()
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

SHARE
%{
%include "read_table-lib"

#ifndef SOURCE_GEN_MAXWELLIAN_DEF
#define SOURCE_GEN_MAXWELLIAN_DEF

/*******************************************************************************
* str_dup_numeric: replaces non 'valid name' chars with spaces
*******************************************************************************/
char *str_dup_numeric_sgm(char *orig)
  {
    long i;

    if (!orig || !strlen(orig)) return(NULL);

    for (i=0; i < strlen(orig); i++)
    {
      if ( (orig[i] > 122)
        || (orig[i] < 32)
        || (strchr("!\"#$%&'()*,:;<=>?@[\\]^`/ ", orig[i]) != NULL) )
      {
        orig[i] = ' ';
      }
    }
    orig[i] = '\0';
    /* now skip spaces */
    for (i=0; i < strlen(orig); i++) {
      if (*orig == ' ') orig++;
      else break;
    }

    return(orig);
  } /* str_dup_numeric_sgm */

/* A normalised Maxwellian distribution in wavelength: Integral over all l = 1 */
#pragma acc routine seq
double SGM_Maxwell(double l, double temp)
{
  double a = 949.0 / temp;
  return 2 * a * a * exp(-a / (l * l)) / (l * l * l * l * l);
}

/* 
 * Sample energy from Maxwell-Boltzmann distribution using Gamma distribution method.
 * The MB energy distribution is: P(E) ~ sqrt(E) * exp(-E / kT)
 * This is a Gamma(3/2, kT) distribution.
 * 
 * Method: Gamma(3/2) = Gamma(1) + Gamma(1/2)
 *   - Gamma(1, kT) = -kT * log(U)
 *   - Gamma(1/2, kT) = kT * N^2 / 4, where N ~ Normal(0,1)
 * 
 * Returns energy in meV, given temperature in Kelvin.
 * kB = 0.08617 meV/K
 */
#pragma acc routine seq
double SGM_sample_maxwell_energy(double temp)
{
  double kT = 0.08617 * temp;  /* kB * T in meV */
  double u1 = rand01();
  double n1 = randnorm();
  
  if (u1 < 1e-10) u1 = 1e-10;  /* Avoid log(0) */
  
  return kT * (-log(u1) + 0.25 * n1 * n1);
}

/*
 * Compute the integrated intensity of a Maxwellian between Emin and Emax.
 * This is used to determine sampling probabilities when multiple temperatures
 * are present.
 * 
 * The integral of sqrt(E)*exp(-E/kT) from Emin to Emax is computed numerically
 * using the incomplete gamma function relationship, but we approximate with
 * a simple acceptance probability estimate.
 */
#pragma acc routine seq
double SGM_maxwell_integral(double temp, double Emin_val, double Emax_val)
{
  /* For simplicity, we estimate the fraction of the Maxwellian that falls
   * within [Emin, Emax] by sampling. The full integral is proportional to
   * (kT)^(3/2), so we return that times an acceptance estimate.
   * 
   * Actually, for proper weighting we just need the relative intensities,
   * so we return I * (kT)^1.5 as a proxy for integrated intensity.
   */
  double kT = 0.08617 * temp;
  return pow(kT, 1.5);
}

#endif
%}

DECLARE
%{
  double p_in;
  double lambda1;  /* first Maxwellian peak wavelength */
  double lambda2;  /* second Maxwellian peak wavelength */
  double lambda3;  /* third Maxwellian peak wavelength */
  t_Table pTable;
  t_Table pTable_x;
  t_Table pTable_y;
  double pTable_xmin;
  double pTable_xmax;
  double pTable_xsum;
  double pTable_ymin;
  double pTable_ymax;
  double pTable_ysum;
  double pTable_dxmin;
  double pTable_dxmax;
  double pTable_dymin;
  double pTable_dymax;
  
  /* For direct Maxwellian sampling */
  int use_direct_maxwell;
  double I1_weight;
  double I2_weight;
  double I3_weight;
  double I_total;
  double E_min_val;
  double E_max_val;
%}

INITIALIZE
%{
  pTable_xsum=0;
  pTable_ysum=0;
  use_direct_maxwell = 0;
  
  double source_area, k;

  if (target_index && !dist)
  {
    Coords ToTarget;
    double tx,ty,tz;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  }

  /* spectrum characteristics */
  if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")) {
    /* Using flux file - fall back to original wavelength sampling */
    use_direct_maxwell = 0;
    
    if (Table_Read(&pTable, flux_file, 1) <= 0)
      exit(fprintf(stderr, "Source_gen_Maxwellian: %s: can not read flux file %s\n", NAME_CURRENT_COMP, flux_file));
    int i;
    if (pTable.columns < 2) exit(fprintf(stderr, "Source_gen_Maxwellian: %s: Flux file %s should contain at least 2 columns [wavelength in Angs,flux].\n", NAME_CURRENT_COMP, flux_file));
    double table_lmin=FLT_MAX, table_lmax=-FLT_MAX;
    double tmin=FLT_MAX, tmax=-FLT_MAX;
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      val = Table_Index(pTable, i,0);
      if (val > tmax) tmax=val;
      if (val < tmin) tmin=val;
    }
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      if (val < 0) fprintf(stderr, "Source_gen_Maxwellian: %s: File %s has negative flux at row %i.\n", NAME_CURRENT_COMP, flux_file, i+1);
      if (flux_file_log)
        val = log(val > 0 ? val : tmin/10);
      Table_SetElement(&pTable, i, 1, val);
      val = Table_Index(pTable, i,0);
      if (val > table_lmax) table_lmax=val;
      if (val < table_lmin) table_lmin=val;
    }
    if (!Lmin && !Lmax && !lambda0 && !dlambda && !E0 && !dE && !Emin && !Emax) {
      Lmin = table_lmin; Lmax = table_lmax;
    }
    if (Lmax > table_lmax) {
      if (verbose) fprintf(stderr, "Source_gen_Maxwellian: %s: Maximum wavelength %g is beyond table range upper limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmax, table_lmax);
      Lmax = table_lmax;
    }
    if (Lmin < table_lmin) {
      if (verbose) fprintf(stderr, "Source_gen_Maxwellian: %s: Minimum wavelength %g is below table range lower limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmin, table_lmin);
      Lmin = table_lmin;
    }
  }
  else if (T1 > 0 && I1 > 0)
  {
    /* Using Maxwellian - enable direct sampling */
    use_direct_maxwell = 1;
    
    k  = 1.38066e-23; /* k_B */
    lambda1  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T1);
    
    if (T2 > 0)
      lambda2  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T2);
    else
      lambda2 = lambda1;

    if (T3 > 0)
      lambda3  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T3);
    else
      lambda3 = lambda1;
      
    /* Compute relative weights for sampling from each Maxwellian.
     * Weight by I * (kT)^1.5 which is proportional to integrated intensity.
     */
    I1_weight = I1 * pow(0.08617 * T1, 1.5);
    I2_weight = (T2 > 0 && I2 > 0) ? I2 * pow(0.08617 * T2, 1.5) : 0;
    I3_weight = (T3 > 0 && I3 > 0) ? I3 * pow(0.08617 * T3, 1.5) : 0;
    I_total = I1_weight + I2_weight + I3_weight;
  }
  else
  {
    /* No Maxwellian, no flux file - uniform distribution */
    use_direct_maxwell = 0;
    lambda1 = lambda0;
    lambda2 = lambda0;
    lambda3 = lambda0;
  }

  /* Read position-divergence files if specified */
  if (xdiv_file && strlen(xdiv_file) && strcmp(xdiv_file,"NULL") && strcmp(xdiv_file,"0")) {
    int i,j;
    if (Table_Read(&pTable_x, xdiv_file, 1) <= 0)
      exit(fprintf(stderr, "Source_gen_Maxwellian: %s: can not read XDiv file %s\n", NAME_CURRENT_COMP, xdiv_file));
    pTable_xsum = 0;
    for (i=0; i<pTable_x.rows; i++)
      for (j=0; j<pTable_x.columns; j++)
        pTable_xsum += Table_Index(pTable_x, i,j);

    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_x.header, "xlimits", "xylimits", NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits, str_dup_numeric_sgm(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits, str_dup_numeric_sgm(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_xmin),  &(pTable_xmax),
      &(pTable_dxmin), &(pTable_dxmax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen_Maxwellian: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, xdiv_file, i);

    if (!xwidth) xwidth=pTable_xmax-pTable_xmin;
    if (!focus_xw && !dist) focus_xw=fabs(pTable_dxmax-pTable_dxmin);
  }

  if (ydiv_file && strlen(ydiv_file) && strcmp(ydiv_file,"NULL") && strcmp(ydiv_file,"0")) {
    int i,j;
    if (Table_Read(&pTable_y, ydiv_file, 1) <= 0)
      exit(fprintf(stderr, "Source_gen_Maxwellian: %s: can not read YDiv file %s\n", NAME_CURRENT_COMP, ydiv_file));
    pTable_ysum = 0;
    for (i=0; i<pTable_y.rows; i++)
      for (j=0; j<pTable_y.columns; j++)
        pTable_ysum += Table_Index(pTable_y, i,j);

    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_y.header, "xlimits", "xylimits", NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits, str_dup_numeric_sgm(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits, str_dup_numeric_sgm(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_ymin),  &(pTable_ymax),
      &(pTable_dymin), &(pTable_dymax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen_Maxwellian: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, ydiv_file, i);
    if (!yheight)  yheight=pTable_ymax-pTable_ymin;
    if (!focus_yh && !dist) focus_yh=fabs(pTable_dymax-pTable_dymin);
  }

  /* Process energy/wavelength parameters */
  if (Emin < 0 || Emax < 0 || Lmin < 0 || Lmax < 0 || E0 < 0 || dE < 0 || lambda0 < 0 || dlambda < 0)
  {
    fprintf(stderr,"Source_gen_Maxwellian: %s: Error: Negative average\n"
                   "            or range values for wavelength or energy encountered\n",
                   NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emin == 0 && Emax > 0) || (dE > 0 && dE >= E0))
  {
    fprintf(stderr,"Source_gen_Maxwellian: %s: Error: minimal energy cannot be less or equal zero\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emax >= Emin) && (Emin > 0))
  { E0 = (Emax+Emin)/2;
    dE = (Emax-Emin)/2;
  }
  if ((E0 > dE) && (dE >= 0))
  {
    Lmin = sqrt(81.81/(E0+dE));
    Lmax = sqrt(81.81/(E0-dE));
  }
  if (Lmax > 0)
  { lambda0 = (Lmax+Lmin)/2;
    dlambda = (Lmax-Lmin)/2;
  }
  
  /* Store energy limits for rejection sampling */
  E_min_val = (Emin > 0) ? Emin : 81.81/(Lmax*Lmax);
  E_max_val = (Emax > 0) ? Emax : 81.81/(Lmin*Lmin);
  
  if (lambda0 <= 0 || (lambda0 < dlambda) || (dlambda < 0))
  { fprintf(stderr,"Source_gen_Maxwellian: %s: Error: Wavelength range %.3f +/- %.3f AA calculated \n",
      NAME_CURRENT_COMP, lambda0, dlambda);
    fprintf(stderr,"- whole wavelength range must be >= 0 \n");
    fprintf(stderr,"- range must be > 0; otherwise intensity gets zero, use other sources in this case \n\n");
    exit(-1);
  }

  radius = fabs(radius); xwidth=fabs(xwidth); yheight=fabs(yheight);  I1=fabs(I1);
  lambda0=fabs(lambda0); dlambda=fabs(dlambda);
  focus_xw = fabs(focus_xw); focus_yh=fabs(focus_yh); dist=fabs(dist);

  if ((!focus_ah && !focus_aw) && (!focus_xw && !focus_yh))
  {
    fprintf(stderr,"Source_gen_Maxwellian: %s: Error: No focusing information.\n"
                   "            Specify focus_xw, focus_yh or focus_aw, focus_ah\n",
                   NAME_CURRENT_COMP);
    exit(-1);
  }
  Lmin = lambda0 - dlambda;
  Lmax = lambda0 + dlambda;

  /* Compute initial weight factor p_in */
  if ((I1 > 0 && T1 >= 0)
     || (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")))
  {
    if (radius)
      source_area = radius*radius*PI*1e4; /* circular cm^2 */
    else
      source_area = yheight*xwidth*1e4; /* square cm^2 */
    p_in  = source_area; /* cm2 */
    
    if (use_direct_maxwell) {
      /* For direct Maxwellian sampling, weight includes the total integrated intensity */
      p_in *= I_total;
    } else {
      /* Original: weight by wavelength range */
      p_in *= (Lmax-Lmin);
      if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")
        && !flux_file_perAA)  p_in *= pTable.rows/(Lmax-Lmin);
    }
  }
  else
    p_in = 1.0/4/PI;
  p_in /= mcget_ncount();
  if (!T1 && I1) p_in *= I1;

  if (radius == 0 && yheight == 0 && xwidth == 0)
  {
    fprintf(stderr,"Source_gen_Maxwellian: %s: Error: Please specify source geometry (radius, yheight, xwidth)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if (focus_xw*focus_yh == 0 && focus_aw == 0 && focus_ah == 0)
  {
    fprintf(stderr,"Source_gen_Maxwellian: %s: Error: Please specify source target (focus_xw, focus_yh or focus_aw, focus_ah)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  
  MPI_MASTER(
  if (verbose)
  {
    printf("Source_gen_Maxwellian: component %s ", NAME_CURRENT_COMP);
    if ((yheight == 0) || (xwidth == 0))
      printf("(disk, radius=%g)", radius);
    else
      printf("(square %g x %g)",xwidth,yheight);
    if (dist) printf("\n            focusing distance dist=%g area=%g x %g\n", dist, focus_xw, focus_yh);
    if (focus_aw || focus_ah) printf("\n            divergence aw=%g ah=%g deg\n", focus_aw, focus_ah);
    printf("            spectra ");
    printf("%.3f to %.3f AA (%.3f to %.3f meV)", Lmin, Lmax, 81.81/Lmax/Lmax, 81.81/Lmin/Lmin);
    printf("\n");
    if (use_direct_maxwell) {
      printf("  DIRECT Maxwellian sampling enabled (efficient for wide energy ranges)\n");
      printf("            T1=%.1f K (%.3f AA), I1=%.3e", T1, lambda1, I1);
      if (T2*I2 != 0)
        printf(", T2=%.1f K (%.3f AA), I2=%.3e", T2, lambda2, I2);
      if (T3*I3 != 0)
        printf(", T3=%.1f K (%.3f AA), I3=%.3e", T3, lambda3, I3);
      printf("\n");
    }
    else if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0"))
    { printf("  File %s for flux distribution used (uniform wavelength sampling).\n", flux_file);
      Table_Info(pTable);
    }
    else if (T1>=0 && I1)
    { printf("  WARNING: Maxwellian with uniform wavelength sampling (less efficient)\n");
      if (T1 != 0)
        printf("            T1=%.1f K (%.3f AA)", T1, lambda1);
      if (T2*I2 != 0)
        printf(", T2=%.1f K (%.3f AA)", T2, lambda2);
      if (T3*I3 != 0)
        printf(", T3=%.1f K (%.3f AA)", T3, lambda3);
      if (T1) printf("\n");
    }
    else
    { printf("  Flux is Phi in [n/s].\n");
    }
  }
  else if (verbose == -1)
    printf("Source_gen_Maxwellian: component %s unactivated", NAME_CURRENT_COMP);
  );
%}

TRACE
%{
  double dx=0, dy=0, xf, yf, rf, pdir, chi, v, r, lambda;
  double E;

  if (verbose >= 0)
  {
    z = 0;

    /* Choose position on source */
    if (radius)
    {
      chi = 2*PI*rand01();
      r = sqrt(rand01())*radius;
      x = r*cos(chi);
      y = r*sin(chi);
    }
    else
    {
      x = xwidth*randpm1()/2;
      y = yheight*randpm1()/2;
    }
    if (zdepth != 0)
      z = zdepth*randpm1()/2;

    /* Sample energy/wavelength */
    if (use_direct_maxwell)
    {
      /* DIRECT Maxwellian sampling using Gamma(3/2) distribution */
      double selected_T, kT;
      double u1, n1;
      
      /* Select which Maxwellian to sample from based on integrated intensities */
      double r_select = rand01() * I_total;
      if (r_select < I1_weight) {
        selected_T = T1;
      } else if (r_select < I1_weight + I2_weight) {
        selected_T = T2;
      } else {
        selected_T = T3;
      }
      
      kT = 0.08617 * selected_T;  /* kB * T in meV */
      
      /* 
       * Sample from Maxwell-Boltzmann energy distribution: P(E) ~ sqrt(E) * exp(-E/kT)
       * This is Gamma(3/2, kT). Use: Gamma(3/2) = Gamma(1) + Gamma(1/2)
       * where Gamma(1) = -log(U) and Gamma(1/2) = N^2/4
       */
      u1 = rand01();
      if (u1 < 1e-10) u1 = 1e-10;
      n1 = randnorm();
      
      E = kT * (-log(u1) + 0.25 * n1 * n1);
      
      /* Check energy bounds */
      if (E < E_min_val || E > E_max_val) {
        ABSORB;
      }
      
      /* Convert energy to velocity */
      v = SE2V * sqrt(E);
      lambda = sqrt(81.81 / E);
    }
    else
    {
      /* Original uniform wavelength sampling */
      lambda = lambda0 + dlambda*randpm1();
      if (lambda <= 0) ABSORB;
      v = K2V*(2*PI/lambda);
    }

    /* Set velocity direction */
    if (!focus_ah && !focus_aw) {
      randvec_target_rect_real(&xf, &yf, &rf, &pdir,
       0, 0, dist, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 2);

      dx = xf-x;
      dy = yf-y;
      rf = sqrt(dx*dx+dy*dy+dist*dist);

      vz = v*dist/rf;
      vy = v*dy/rf;
      vx = v*dx/rf;
    } else {
      randvec_target_rect_angular(&vx, &vy, &vz, &pdir,
          0, 0, 1, focus_aw*DEG2RAD, focus_ah*DEG2RAD, ROT_A_CURRENT_COMP);
      dx = vx; dy = vy;
      vx *= v; vy *= v; vz *= v;
    }
    p = p_in*pdir;

    /* Spectral weighting for non-direct sampling modes */
    if (!use_direct_maxwell)
    {
      if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0"))
      {
         double binwidth = Table_Value(pTable, lambda, 1);
         if (flux_file_log) binwidth = exp(binwidth);
         p *= binwidth;
      }
      else if (T1 > 0 && I1 > 0)
      {
        double Maxwell = I1 * SGM_Maxwell(lambda, T1);

        if ((T2 > 0) && (I2 > 0))
          Maxwell += I2 * SGM_Maxwell(lambda, T2);
        if ((T3 > 0) && (I3 > 0))
          Maxwell += I3 * SGM_Maxwell(lambda, T3);
        p *= Maxwell;
      }
    }

    /* Optional position-divergence weighting from files */
    if (xdiv_file && strlen(xdiv_file)
      && strcmp(xdiv_file,"NULL") && strcmp(xdiv_file,"0") && pTable_xsum > 0) {
      double i,j;
      j = (x - pTable_xmin) / (pTable_xmax - pTable_xmin) * pTable_x.columns;
      i = (atan2(dx,rf)*RAD2DEG - pTable_dxmin) / (pTable_dxmax - pTable_dxmin) * pTable_x.rows;
      r = Table_Value2d(pTable_x, i, j);
      p *= r/pTable_xsum;
    }
    if (ydiv_file && strlen(ydiv_file)
       && strcmp(ydiv_file,"NULL") && strcmp(ydiv_file,"0") && pTable_ysum > 0) {
      double i,j;
      j = (y - pTable_ymin) / (pTable_ymax - pTable_ymin) * pTable_y.columns;
      i = (atan2(dy,rf)*RAD2DEG - pTable_dymin) / (pTable_dymax - pTable_dymin) * pTable_y.rows;
      r = Table_Value2d(pTable_y, i, j);
      p *= r/pTable_ysum;
    }

    SCATTER;
  }
%}

FINALLY
%{
  Table_Free(&pTable);
  Table_Free(&pTable_x);
  Table_Free(&pTable_y);
%}

MCDISPLAY
%{
  double xmin;
  double xmax;
  double ymin;
  double ymax;

  if (radius)
  {
    circle("xy",0,0,0,radius);
    if (zdepth) {
      circle("xy",0,0,-zdepth/2,radius);
      circle("xy",0,0, zdepth/2,radius);
    }
  }
  else
  {
    xmin = -xwidth/2; xmax = xwidth/2;
    ymin = -yheight/2; ymax = yheight/2;

    multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
    if (zdepth) {
      multiline(5, (double)xmin, (double)ymin, -zdepth/2,
             (double)xmax, (double)ymin, -zdepth/2,
             (double)xmax, (double)ymax, -zdepth/2,
             (double)xmin, (double)ymax, -zdepth/2,
             (double)xmin, (double)ymin, -zdepth/2);
      multiline(5, (double)xmin, (double)ymin, zdepth/2,
             (double)xmax, (double)ymin, zdepth/2,
             (double)xmax, (double)ymax, zdepth/2,
             (double)xmin, (double)ymax, zdepth/2,
             (double)xmin, (double)ymin, zdepth/2);
    }
  }
  if (dist) {
    if (focus_aw) focus_xw=dist*tan(focus_aw*DEG2RAD);
    if (focus_ah) focus_yh=dist*tan(focus_ah*DEG2RAD);
    dashed_line(0,0,0, -focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2, focus_yh/2,dist, 4);
    dashed_line(0,0,0, -focus_xw/2, focus_yh/2,dist, 4);
  }
%}

END
